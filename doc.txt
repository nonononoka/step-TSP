homework1
・実行の仕方
homework1.cppを実行すると、行列サイズを聞かれるので入力します。(5*5だったら5と入力)
i,j,kの順番による実行時間が標準出力に出力されます。
i,j,kの順番と実行時間の関係をグラフにしたものを別で出しました。

・結果

homework2
未完



homework3
・実行の仕方

problem1~5についてはTSP_kai.cppで動きます。
どのファイルを入力するか聞かれるので、ファイル番号を打つとoutputファイルに結果が出力されます。
problem6以降については、TSP_kai_big.cppで動きます。

・考えた方法
元々、nearest_insert関数で出たtourを出力していましたが、これよりさらに最適化するためtwo_optとthree_optを組み合わせたアルゴリズムを用いました。
(nearest_insertで、出したtourはクロスしていないためtwo_optだけではダメ)

A-B,C-D,E-Fという3つの枝の繋ぎかえを行うとき、以下の7通りの繋ぎ方が出てきます。
    ①一つはそのまま残して残り2つを繋ぎかえる場合(two_opt)
    A-C,B-D,E-F
    A-B,C-E,D-F
    F-B,C-D,E-A
    ②3つ全部繋ぎかえる場合(three-opt)
    A-E,D-B,C-F
    A-D,E-C,B-F
    A-D,E-B,C-F
    A-C,E-B,F-D

上の7つのうちで距離が最小となるものを選ぶことを繰り返し、それ以上最適化できなくなったら終了。


・計算量
nearest_insertはO(n^3)ですが、two_three_optは、while文が何周するか分からないので、見積もれません。
problem1~5については、かかっても数分で終わりましたが6以降は終わりそうになかったので、pythonより速いとされるC++で書き直し→変わらず数時間かかり、途中で諦めました。

6以降については、もっと別の方法が必要。
例えば？
nearest_insertで出された経路より小さいものが出たらそこで処理終了とか？これが、TSP_kai_6.cppとTSP_kai_7.cpp
