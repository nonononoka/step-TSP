homework1
hw1フォルダにあります。
・実行の仕方
homework1.cppを実行すると、行列サイズを聞かれるので入力します。(5*5だったら5と入力)
入力したサイズをNとすると、サイズが1*1~N*Nまでの行列積の実行時間が、ijkの順番ごとにtxtファイルに出力されます。
homework1_output.pyを実行すると先の出力されたtxtファイルをグラフ化して、hw1_output.pngが出力されます。
今回はN=200までで、i,j,kの順番と実行時間の関係をグラフにしたものを別で出しました。

・結果
hw1_output.pngにあります。
重なっているので分かりにくいですが、ikjとjik、jkiとkijが全くおなじ結果になっています。
結果は、ijk<ikj=jik<jki=kij<kjiとなりました。

???????
c[i][j] += a[i][k] * b[k][j]で計算した場合、
連続アクセスになるものは、ikj、kijなのでこれが一番早そう。
その次に、ijk、jik(それぞれ、b[k][j]のみ不連続アクセス)
最後に、jki、kji(c[i][j]とa[i][k]が不連続アクセス)
なので、実行時間はikj=kij<ijk=jik<jki=kjiの順番と予想しいていましたが、だいぶ異なった結果に・・・

homework2

授業のまとめ
1,C++で実行時間に差が出るのは？
連続アクセスが検知されると周辺のデータもCPUレジスタに読み込むことが行われる(プリフェッチ)から。
→プリフェッチされているかどうかで、実行時間が変わる。

2,pythonとC++の違いは？
インタプリタかコンパイラか。
インタプリタ・・・字句解析→構文解析→評価
コンパイラ・・・字句解析→構文解析→最適化→機械語生成→機械語実行

これらを踏まえると、pythonで実行時間に差が出ないのは、プリフェッチが行われていないからと考えられる。
プリフェッチが行われないのは、なぜか？

以下仮説
そもそも、行方向にメモリが連続でないとしたら(確かfortranは並び方がC++と逆だったはず・・)
でも列方向にメモリが連続なら、プリフェッチで差が出るはず・・

分からない・・

homework3
正田さんのコードを参考にしました。

・実行の仕方

problem1~5についてはTSP_kai.cppで動きます。
どのファイルを入力するか聞かれるので、ファイル番号を打つとoutputファイルに結果が出力されます。
problem6以降については、TSP_kai_big.cppで動きます。

・考えた方法
元々、nearest_insert関数で出たtourを出力していましたが、これよりさらに最適化するためtwo_optとthree_optを組み合わせたアルゴリズムを用いました。
(nearest_insertで、出したtourはクロスしていないためtwo_optだけではダメ)

A-B,C-D,E-Fという3つの枝の繋ぎかえを行うとき、以下の7通りの繋ぎ方が出てきます。
    ①一つはそのまま残して残り2つを繋ぎかえる場合(two_opt)
    A-C,B-D,E-F
    A-B,C-E,D-F
    F-B,C-D,E-A
    ②3つ全部繋ぎかえる場合(three-opt)
    A-E,D-B,C-F
    A-D,E-C,B-F
    A-D,E-B,C-F
    A-C,E-B,F-D

上の7つのうちで距離が最小となるものを選ぶことを繰り返し、それ以上最適化できなくなったら終了。

problem6以降については、少し方法を変えました。
<TSP_kai.cppとの変更点>
    1 nearest_insertで、始点を1~20までに絞った。(点はバラバラに配置されているので、1~20の連続した点とした)
    2 two_three_optについては、最適化するまで探索するのは無理なので、5回two_three_optを行なって、初めにnearest_insertで出した経路も併せて6つの経路のうち、一番距離が小さくなるものを出力とした。(problem6については、一回のoptに30分くらいかかる。)


・計算量
nearest_insertはO(n^3)ですが、two_three_optは、while文が何周するか分からないので、見積もれません。
problem1~5については、かかっても数分で終わりましたが6以降は終わりそうになかったので、pythonより速いとされるC++で書き直し→変わらず数時間かかり、途中で諦めました。
6以降については、もっと別の方法が必要。
→TSP_kai_big.cpp



